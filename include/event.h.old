/*
 * ++C - C++ introduction
 * Copyright (C) 2013, 2014, 2015, 2016 Wilhelm Meier <wilhelm.meier@hs-kl.de>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <stdint.h>

#include "config.h"
#include "mcu.h"
#include "timer.h"
#include "fifo.h"
#include "disable.h"

enum class EventType : uint8_t {
    NoEvent,
    Test,
    Timer,
    UsartRecv0, UsartRecv1, UsartRecv2,
    UsartFe0, UsartFe1, UsartFe2,
    UsartUpe0, UsartUpe1, UsartUpe2,
    UsartDor0, UsartDor1, UsartDor2,
    SwUsartRecv0, SwUsartRecv1,
    Spi0, Spi1,
    HottBinaryRequest, HottAsciiRequest, HottSensorBroadcast, HottAsciiKey,
    Ppm1Up, Ppm1Down, Ppm2Up, Ppm2Down,
    ButtonPress,
    ButtonPress0, ButtonPress1, ButtonPress2, ButtonPress3, ButtonPress4, ButtonPress5, ButtonPress6, ButtonPress7,
};

template<typename T>
struct Event
{
    EventType type;
    T value;
};

typedef Event<uint8_t> Event8u_t;

namespace AVR {
template<uint8_t N, typename PA, typename MCU> class Usart;
template<uint8_t N, typename MCU> class Spi;
template<uint8_t N> class SWUsart;
}

namespace Hott {
class HottProtocollAdapter;
}

template<int N, typename T, typename... TT>
class Processor {
public:
    static void process(const Event8u_t& e) {
        if (e.type == T::eventType) {
            T::process(e.value);
        }
        Processor<N - 1, TT..., void>::process(e);
    }

private:
};
template<typename... TT>
class Processor<0, void, TT...> {
public:
    static void process(const Event8u_t&) {}
};

class EventManager
{
    friend class Hott::HottProtocollAdapter;
    template<typename MCUUsart> friend class Timer;
    template<uint8_t N, typename MCU> friend class AVR::Usart;
    template<uint8_t N, typename MCU> friend class AVR::Spi;
    template<uint8_t N> friend class SWUsart;
public:
    EventManager() = delete;

    static bool enqueue(const Event8u_t& event) {
        return fifo().push_back(event); // lockfree fifo
    }
    template<typename... TT, typename P>
    static void run(const P& periodic) {
        while(true) {
            periodic();
            if (auto event = fifo().pop_front()) {
                Processor<sizeof...(TT), TT...>::process(*event);
            }
        }
    }
    template<typename... TT>
    static void run() {
        while(true) {
            if (auto event = fifo().pop_front()) {
                Processor<sizeof...(TT), TT...>::process(*event);
            }
        }
    }

//    template<typename P, typename T, typename... TT>
//    static void run(const P& periodic, const T& r, const TT&... rr) {
//        while(true) {
//            periodic();
//            if (auto event = fifo().pop_front()) {
//                process(*event, r, rr...);
//            }
//        }
//    }
protected:
    static bool enqueueISR(const Event8u_t& event) {
        return fifo().push_back(event);
    }
private:
//    static void process(const Event8u_t&) {}

//    template<typename T, typename... TT>
//    static void process(const Event8u_t& event, const T& r, const TT&... tt) {
//        if (event.type == r.eventType) {
//            r(event.value);
//        }
//        process(event, tt...);
//    }

    // header only: to avoid static data member
    static std::FiFo<Event8u_t, Config::EventManager::EventQueueLength>& fifo() {
        static std::FiFo<Event8u_t, Config::EventManager::EventQueueLength> fifo;
        return fifo;
    }

};

//template<EventType Type, typename Parameter>
//class EventHandler {
//    friend class EventManager;
//protected:
//    inline EventHandler(const Parameter& p) :
//        parameter(p) {}
//    const Parameter& parameter;
//public:
//    static constexpr EventType eventType = Type;
//};

template<EventType Type>
class EventHandler {
    friend class EventManager;
public:
    static constexpr EventType eventType = Type;
};
