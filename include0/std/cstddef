#pragma once

#include <stddef.h>

#include "bits/byte.h"

/*
namespace std {
#define __cpp_lib_byte 201603

  /// std::byte
  enum class byte : unsigned char {};

  template<typename _IntegerType> struct __byte_operand { };
  template<> struct __byte_operand<bool> { using __type = byte; };
  template<> struct __byte_operand<char> { using __type = byte; };
  template<> struct __byte_operand<signed char> { using __type = byte; };
  template<> struct __byte_operand<unsigned char> { using __type = byte; };
#ifdef _GLIBCXX_USE_WCHAR_T
  template<> struct __byte_operand<wchar_t> { using __type = byte; };
#endif
  template<> struct __byte_operand<char16_t> { using __type = byte; };
  template<> struct __byte_operand<char32_t> { using __type = byte; };
  template<> struct __byte_operand<short> { using __type = byte; };
  template<> struct __byte_operand<unsigned short> { using __type = byte; };
  template<> struct __byte_operand<int> { using __type = byte; };
  template<> struct __byte_operand<unsigned int> { using __type = byte; };
  template<> struct __byte_operand<long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long> { using __type = byte; };
  template<> struct __byte_operand<long long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long long> { using __type = byte; };
#if defined(__GLIBCXX_TYPE_INT_N_0)
  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_0>
  { using __type = byte; };
  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_0>
  { using __type = byte; };
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_1>
  { using __type = byte; };
  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_1>
  { using __type = byte; };
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_2>
  { using __type = byte; };
  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_2>
  { using __type = byte; };
#endif
  template<typename _IntegerType>
    struct __byte_operand<const _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<volatile _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> { };

  template<typename _IntegerType>
    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator<<=(byte& __b, _IntegerType __shift) noexcept
    { return __b = byte(static_cast<unsigned char>(__b) << __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator<<(byte __b, _IntegerType __shift) noexcept
    { return byte(static_cast<unsigned char>(__b) << __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator>>=(byte& __b, _IntegerType __shift) noexcept
    { return __b = byte(static_cast<unsigned char>(__b) >> __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator>>(byte __b, _IntegerType __shift) noexcept
    { return byte(static_cast<unsigned char>(__b) >> __shift); }

  constexpr byte&
  operator|=(byte& __l, byte __r) noexcept
  {
    return __l =
      byte(static_cast<unsigned char>(__l) | static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator|(byte __l, byte __r) noexcept
  {
    return
      byte(static_cast<unsigned char>(__l) | static_cast<unsigned char>(__r));
  }

  constexpr byte&
  operator&=(byte& __l, byte __r) noexcept
  {
   return __l =
     byte(static_cast<unsigned char>(__l) & static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator&(byte __l, byte __r) noexcept
  {
    return
      byte(static_cast<unsigned char>(__l) & static_cast<unsigned char>(__r));
  }

  constexpr byte&
  operator^=(byte& __l, byte __r) noexcept
  {
    return __l =
      byte(static_cast<unsigned char>(__l) ^ static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator^(byte __l, byte __r) noexcept
  {
    return
      byte(static_cast<unsigned char>(__l) ^ static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator~(byte __b) noexcept
  { return byte(~static_cast<unsigned char>(__b)); }

  template<typename _IntegerType>
    constexpr _IntegerType
    to_integer(__byte_op_t<_IntegerType> __b) noexcept
    { return _IntegerType(__b); }

} // namespace std
*/
